% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/repair-names.R
\name{name-repair}
\alias{name-repair}
\alias{tidy_names}
\alias{set_tidy_names}
\alias{repair_names}
\title{Repair the names of a vector}
\usage{
tidy_names(name, syntactic = FALSE, quiet = FALSE)

set_tidy_names(x, quiet = FALSE)

repair_names(x, prefix = "V", sep = "")
}
\arguments{
\item{name}{A \code{names} attribute, usually a character vector.}

\item{syntactic}{Should all names be made syntactically valid via
\code{\link[=make.names]{make.names()}}?}

\item{quiet}{Whether to suppress messages about name repair.}

\item{x}{A vector.}

\item{prefix}{A string, the prefix to use for new column names.}

\item{sep}{A string inserted between the column name and de-duplicating
number.}
}
\value{
\code{x} with repaired names or a repaired version of \code{name}.
}
\description{
tibble deals with a few levels of name repair:
\itemize{
\item \code{minimal} names exist. The \code{names} attribute is not \code{NULL}. The name of
an unnamed element is \code{""} and never \code{NA}. Enforced internally by
\code{\link[=tibble]{tibble()}} and \code{\link[=as_tibble]{as_tibble()}}, even when \code{.name_repair = "none"}, and there
is no opt-out.
\item \code{unique} names are \code{minimal}, have no duplicates, and are never empty
(literally, no \code{""}s).
\item \code{syntactic} names are \code{unique} and syntactic (see Details for more).
}

\code{syntactic} implies \code{unique}, \code{unique} implies \code{minimal}.

The \code{.name_repair} argument of \code{\link[=tibble]{tibble()}} and \code{\link[=as_tibble]{as_tibble()}} refers to these
levels. Alternatively, the user can pass their own name repair function. It
should anticipate \code{minimal} names as input and should, likewise, return names
that are at least \code{minimal}.

\code{tidy_names()} and \code{set_tidy_names()} ... WHAT I WANT TO SAY:
they were our first pass as providing access to our name repair strategies,
which we still want to do. That is, we'd like to export utilities around
\code{minimal} and (our take on) \code{unique} and \code{syntactic} names. But ... not yet
and probably not here. The old "tidy with \code{syntactic = FALSE}" is the new
\code{unique} and the old "tidy with \code{syntactic = TRUE} is new \code{syntactic}.

\code{repair_names()} is an older function with different renaming
heuristics and is being deprecated. In new code, use \code{as_tibble()} and
specify a \code{.name_repair} strategy.
}
\section{\code{minimal} names}{


\code{minimal} names exist. The \code{names} attribute is not \code{NULL}. The name of an
unnamed element is \code{""} and never \code{NA}.

\code{tbl_df} objects created by tibble will have variable names that are
\code{minimal}, at the very least, Why? General name repair can be be implemented
more simply if the baseline strategy ensures that \code{names(x)} returns a
character vector of the correct length.

Examples:\preformatted{Original names of a vector with length 3: NULL
                         `minimal` names: "" "" ""

                          Original names: "x" NA
                         `minimal` names: "x" ""
}

Related: \code{\link[rlang:names2]{rlang::names2()}} returns the names of an object, after making them
\code{minimal}.
}

\section{\code{unique} names}{


\code{unique} names are \code{minimal}, have no duplicates, and are never empty
(literally, no \code{""}s).

You usually want \code{unique} variable names in a tibble, because they ensure
that any variable can be identified, uniquely, by its name.

There are many ways to make names \code{unique}. We do so by appending a suffix of
the form \code{..j} to any name that is \code{""} or a duplicate, where \code{j} is the
position. Why?
\itemize{
\item An absolute position \code{j} is more helpful than numbering within the columns
that share a name. Context: troubleshooting data import with lots of columns
and dysfunctional names.
\item We hypothesize that it's better have a "level playing field" when repairing
names, i.e. if \code{foo} appears twice, they both get repaired, not just the
second occurence.
}

Example:\preformatted{Original names:    ""    "x"    "" "y"    "x"
`unique` names: "..1" "x..2" "..3" "y" "x..5"
}

Why would you ever want \code{minimal} names, instead of \code{unique} or \code{syntactic}
ones? Sometimes the first row of a data source -- allegedly variable names --
actually contains \strong{data} and the resulting tibble will be reshaped with,
e.g., \code{tidyr::gather()}. In this case, it is better to not munge the names at
import.

Pre-existing suffixes of the form \code{..j} are always stripped, prior to making
names \code{unique}, i.e. reconstructing the suffixes. If this interacts poorly
with your names, you should take control of name repair.
}

\section{\code{syntactic} names}{


\code{syntactic} names are \code{unique} and syntactic (quoting from \code{\link[=make.names]{make.names()}}),
meaning they:
\itemize{
\item Have no duplicates (inherited from \code{unique}).
\item Consist of letters, numbers, and the dot \code{.} or underscore \code{_}
characters.
\item Start with a letter or the dot \code{.}, not followed by a number.
\item Not a reserved word.
}

\code{syntactic} names are easy to use "as is" in code. They do not require
quoting and work well with nonstandard evaluation, such as list indexing via
\code{$} or in packages like dplyr and ggplot2.

There are many ways to make names \code{syntactic}. For example, we choose to
define \code{syntactic} names as an extension of \code{unique}, i.e. \code{syntactic}
implies unique. Why? Because the need for syntactic names is strongly
associated with the need for uniqueness and this makes the name repair system
simpler.
}

\examples{
# Works for lists and vectors, too:
set_tidy_names(3:5)
set_tidy_names(list(3, 4, 5))

# Clean data frames are left unchanged:
set_tidy_names(mtcars)

# By default, all rename operations are printed to the console:
tbl <- as_tibble(structure(list(3, 4, 5), class = "data.frame"), .name_repair = "none")
set_tidy_names(tbl)

# Alternatively, use tidy_names() to assign the result manually:
new_names <- tidy_names(names(tbl))
rlang::set_names(tbl, new_names)

# Optionally, names can be made syntactic:
tidy_names("a b")
}
