% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/repair-names.R
\name{name-repair}
\alias{name-repair}
\alias{tidy_names}
\alias{set_tidy_names}
\alias{repair_names}
\title{Repair the names of a vector}
\usage{
tidy_names(name, syntactic = FALSE, quiet = FALSE)

set_tidy_names(x, syntactic = FALSE, quiet = FALSE)

repair_names(x, prefix = "V", sep = "")
}
\arguments{
\item{name}{A \code{names} attribute, usually a character vector.}

\item{syntactic}{Should names be made syntactically valid?}

\item{quiet}{Whether to suppress messages about name repair.}

\item{x}{A vector.}

\item{prefix}{A string, the prefix to use for new column names.}

\item{sep}{A string inserted between the column name and de-duplicating
number.}
}
\value{
\code{x} with repaired names or a repaired version of \code{name}.
}
\description{
tibble deals with a few levels of name repair:
\itemize{
\item \code{minimal} names exist. The \code{names} attribute is not \code{NULL}. The name of
an unnamed element is \code{""} and never \code{NA}.
\item \code{unique} names are \code{minimal}, have no duplicates, and are never empty
(literally, no \code{""}s).
\item \code{syntactic} names are \code{unique} and syntactic (see Details for more).
}

\code{syntactic} implies \code{unique}, \code{unique} implies \code{minimal}. These levels are
nested.

The \code{.name_repair} argument of \code{\link[=tibble]{tibble()}} and \code{\link[=as_tibble]{as_tibble()}} refers to these
levels. Alternatively, the user can pass their own name repair function. It
should anticipate \code{minimal} names as input and should, likewise, return names
that are at least \code{minimal}.

The "Life cycle" section explains the status of the existing functions
\code{tidy_names()}, \code{set_tidy_names()}, and \code{repair_names()}.
}
\section{\code{minimal} names}{


\code{minimal} names exist. The \code{names} attribute is not \code{NULL}. The name of an
unnamed element is \code{""} and never \code{NA}.

\code{tbl_df} objects created by \code{\link[=tibble]{tibble()}} and \code{\link[=as_tibble]{as_tibble()}} have variable names
that are \code{minimal}, at the very least.
Why? General name repair can be be implemented more simply if the baseline
strategy ensures that \code{names(x)} returns a character vector of the correct
length.

Examples:\preformatted{Original names of a vector with length 3: NULL
                           minimal names: "" "" ""

                          Original names: "x" NA
                           minimal names: "x" ""
}

Related: \code{\link[rlang:names2]{rlang::names2()}} returns the names of an object, after making them
\code{minimal}.
}

\section{\code{unique} names}{


\code{unique} names are \code{minimal}, have no duplicates, and are never empty
(literally, no \code{""}s).

You usually want \code{unique} variable names in a data.frame, because they ensure
that any variable can be identified, uniquely, by its name. Indexing by name
works.

There are many ways to make names \code{unique}. We append a suffix of the form
\code{..j} to any name that is \code{""} or a duplicate, where \code{j} is the position.
Why?
\itemize{
\item An absolute position \code{j} is more helpful than numbering within the columns
that share a name. Context: troubleshooting data import with lots of columns
and dysfunctional names.
\item We hypothesize that it's better have a "level playing field" when repairing
names, i.e. if \code{foo} appears twice, they both get repaired, not just the
second occurence.
}

Example:\preformatted{Original names:    ""    "x"    "" "y"    "x"
  unique names: "..1" "x..2" "..3" "y" "x..5"
}

Why would you ever want \code{minimal} names, instead of \code{unique} or \code{syntactic}
ones? Sometimes the first row of a data source -- allegedly variable names --
actually contains \strong{data} and the resulting tibble will be reshaped with,
e.g., \code{tidyr::gather()}. In this case, it is better to not munge the names at
import.

Pre-existing suffixes of the form \code{..j} are always stripped, prior to making
names \code{unique}, i.e. reconstructing the suffixes. If this interacts poorly
with your names, you should take control of name repair.
}

\section{\code{syntactic} names}{


\code{syntactic} names are \code{unique} and syntactic, meaning they:
\itemize{
\item Have no duplicates (inherited from \code{unique}).
\item Consist of letters, numbers, and the dot \code{.} or underscore \code{_}
characters.
\item Start with a letter or start with the dot \code{.} not followed by a number.
\item Are not a reserved word, e.g., \code{if} or \code{function} or \code{TRUE}.
\item Are not \code{...}. Do not have the form \code{..i}, where \code{i} is a number.
}

\code{syntactic} names are easy to use "as is" in code. They do not require
quoting and work well with nonstandard evaluation, such as list indexing via
\code{$} or in packages like dplyr and ggplot2.

There are many ways to fix a non-syntactic name. Here's how our logic
compares to \code{\link[base:make.names]{base::make.names()}} for a single name:
\itemize{
\item Same: Definition of what is syntactically valid.
\item Same: Invalid characters are replaced with \code{.}.
\item Different: We always fix a name by prepending a \code{.}. \code{\link[base:make.names]{base::make.names()}}
sometimes prefixes with \code{X} and at other times appends a \code{.}.
\item Different: We treat \code{NA} and \code{""} the same: both become \code{.}.
\code{\link[base:make.names]{base::make.names()}} turns \code{NA} in \code{"NA."} and \code{""} into \code{"X"}.
\item Different: We turn \code{...} into \code{....} and \code{..i} into \code{...i} (\code{i} is a
number). \code{\link[base:make.names]{base::make.names()}} does not modify \code{...} or \code{..i}, which could
be regarded as a bug (?).
}

Additionally, when dealing with the vector of names for a tibble, we choose
to implement \code{syntactic} names as an extension of \code{unique}, i.e. \code{syntactic}
implies unique. Why? Because the need for syntactic names is strongly
associated with the need for uniqueness and this makes the name repair system
simpler.
}

\section{Life cycle}{

\code{tidy_names()}, \code{set_tidy_names()}, and \code{repair_names()} were early efforts
to facilitate \emph{post hoc} name repair in tibble, given that \code{tibble()} and
\code{as_tibble()} did not do this.

From tibble v1.5.0, the \code{.name_repair} argument gives direct access to three
specific levels of name repair: \code{minimal}, \code{unique}, and \code{syntactic}. We
recommend that new code use this instead of \code{tidy_names()},
\code{set_tidy_names()}, or \code{repair_names()}. After a period of use, the repair
stategies behind \code{minimal}, \code{unique}, and \code{syntactic} are likely to be
exposed in standalone functions and this could affect the behaviour of
\code{tidy_names()}. \code{repair_names()} should be considered deprecated.\preformatted{tibble(..., `.name_repair = "unique"`)
## is preferred to
df <- tibble(...)
set_tidy_names(df, syntactic = FALSE)

tibble(..., `.name_repair = "syntactic"`)
## is preferred to
df <- tibble(...)
set_tidy_names(df, syntactic = TRUE)
}
}

\examples{
\dontrun{
## by default, duplicate names are not allowed
tibble(x = 1, x = 2)
}
## you can authorize duplicate names
tibble(x = 1, x = 2, .name_repair = "minimal")
## or request that the names be made unique
tibble(x = 1, x = 2, .name_repair = "unique")

## by default, non-syntactic names are allowed
df <- tibble(`a 1` = 1, `a 2` = 2)
## because you can still index by name
df[["a 1"]]
df$`a 1`

## syntactic names are easier to work with, though, and you can request them
df <- tibble(`a 1` = 1, `a 2` = 2, .name_repair = "syntactic")
df$a.1

## you can specify your own name repair function
tibble(x = 1, x = 2, .name_repair = make.unique)

fix_names <- function(x) gsub("\%", " percent", x)
tibble(`25\%` = 1, `75\%` = 2, .name_repair = fix_names)

fix_names <- function(x) gsub("\\\\s+", "_", x)
tibble(`year 1` = 1, `year 2` = 2, .name_repair = fix_names)

## the names attibute will be non-NULL, with "" as the default element
df <- as_tibble(list(1:3, letters[1:3]), .name_repair = "minimal")
names(df)
}
