% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/repair-names.R
\name{name-repair}
\alias{name-repair}
\alias{tidy_names}
\alias{set_tidy_names}
\alias{repair_names}
\title{Repair the names of a vector}
\usage{
tidy_names(name, syntactic = FALSE, quiet = FALSE)

set_tidy_names(x, quiet = FALSE)

repair_names(x, prefix = "V", sep = "")
}
\arguments{
\item{name}{A \code{names} attribute, usually a character vector.}

\item{syntactic}{Should all names be made syntactically valid via \code{\link[=make.names]{make.names()}}?}

\item{quiet}{Whether to suppress messages about name repair.}

\item{x}{A vector.}

\item{prefix}{A string, the prefix to use for new column names.}

\item{sep}{A string inserted between the column name and de-duplicating
number.}
}
\value{
\code{x} with repaired names or a repaired version of \code{name}.
}
\description{
tibble deals with a few levels of name repair:
\itemize{
\item \code{minimal} names exist. The \code{names} attribute is not \code{NULL}. The name of
an unnamed element is \code{""} (never \code{NA}). Enforced internally by \code{\link[=tibble]{tibble()}}
and \code{\link[=as_tibble]{as_tibble()}} and there is no opt-out.
\item \code{valid} names exist, are never empty (literally, no \code{""}s), and have no
duplicates.
\item \code{syntactic} names are \code{valid} and syntactic, meaning they fulfill these
criteria (quoting from \code{\link[=make.names]{make.names()}}):
\itemize{
\item Consist of letters, numbers and the dot or underline characters and
start with a letter or the dot not followed by a number.
\item Not a reserved word.
}
}

\code{syntactic} implies \code{valid}, \code{valid} implies \code{minimal}.

These are the levels referred to by the \code{.name_repair} argument of, e.g.,
\code{\link[=tibble]{tibble()}} and \code{\link[=as_tibble]{as_tibble()}}. Alternatively, the user can pass their own name
repair function. It can assume \code{minimal} names as input and should, likewise,
return names that are at least \code{minimal}.

\code{repair_names()} is an older function with different renaming
heuristics and is being deprecated. In new code, use \code{as_tibble()} and
specify a \code{.name_repair} strategy.
}
\section{\code{minimal} names}{


\code{tbl_df} objects created by tibble will have names that are, at the very
least, \code{minimal}. A convenient consequence is that \code{names(x)} returns a
character vector of the correct length, suitable for other name repair
strategies.
}

\section{\code{valid} names}{


\code{valid} names are created by appending a suffix of the form \code{..j} to any name
that is \code{""} or a duplicate, where \code{j} is the position. This is advantageous
for tibbles, because it ensures that any variable can be identified,
uniquely, by its name. The absolute position \code{j} is helpful when
troubleshooting data import with lots of columns and dysfunctional names.

Example:\preformatted{Original names:    ""    "x"    "" "y"    "x"
 `valid` names: "..1" "x..2" "..3" "y" "x..5"
}
}

\section{\code{syntactic} names}{


\code{syntactic} names are easy to use "as is" in code. They do not require
quoting and work well with nonstandard evaluation, such as list indexing via
\code{$}. TODO: highlight how munging differs from \code{make.names()}, i.e. uses
conventions more consistent with \code{valid} names and the tidyverse. TODO:
something about suffix reorganization.
}

\examples{
# Works for lists and vectors, too:
set_tidy_names(3:5)
set_tidy_names(list(3, 4, 5))

# Clean data frames are left unchanged:
set_tidy_names(mtcars)

# By default, all rename operations are printed to the console:
tbl <- as_tibble(structure(list(3, 4, 5), class = "data.frame"), .name_repair = "none")
set_tidy_names(tbl)

# Alternatively, use tidy_names() to assign the result manually:
new_names <- tidy_names(names(tbl))
rlang::set_names(tbl, new_names)

# Optionally, names can be made syntactic:
tidy_names("a b")
}
