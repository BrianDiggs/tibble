---
title: "Invariants for subsetting and subassignment"
#output: rmarkdown::word_document
output: rmarkdown::html_vignette
# devtools::load_all(); rmarkdown::render("vignettes/invariants.Rmd", output_format = rmarkdown::md_document(preserve_yaml = TRUE)); system("pandoc vignettes/invariants.md -o vignettes/invariants.html")
vignette: >
  %\VignetteIndexEntry{invariants}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">
.dftbl {
    width: 100%;
    table-layout: fixed;
    display: inline-table;
}

.error pre code {
    color: red;
}

.warning pre code {
    color: violet;
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  error = TRUE,
  collapse = TRUE,
  #eval = FALSE, echo = FALSE,
  comment = "#>"
)

tibble:::set_dftbl_hooks()

options(
  lifecycle_disable_warnings = FALSE,
  lifecycle_verbose_soft_deprecation = TRUE,
  lifecycle_repeat_warnings = TRUE
)
```

This vignette defines invariants in the behavior of `$`, `[[` and `[`, and their assignment counterparts `$<-`, `[[<-` and `[<-`, for tibbles, and illustrates where these differ from data frames.
The goal is to determine a small set of invariants that consistently define how behaviors interact.
For each invariant an example is given.
Currently, the `vignette("subset")` and `vignette("subassign")` articles give a more comprehensive overview, but will be merged into this article at some point.

Some behaviors are defined using functions of the vctrs package, in particular `vec_slice()`, `vec_recycle()` and `vec_as_index()`.
In this article, all behaviors are demonstrated using one example data frame and its tibble equivalent.

```{r setup}
library(vctrs)
library(tibble)

new_df <- function() {
  df <- data.frame(n = 1:4)
  df$c <- letters[5:8]
  df$li <- list(9, 10:11, 12:14, "text")
  df
}

new_tbl <- function() {
  as_tibble(new_df())
}
```

Results of the same code for data frames and tibbles are presented side by side:

```{r show, dftbl = TRUE, dftbl_always = TRUE}
new_df()
```

In the following, if the results are identical (after converting to a data frame if necessary), only the tibble result is shown, as in the example below.
This makes it easier to spot differences.

```{r show-compare, dftbl = TRUE}
new_df()
```

Subsetting operations are read-only.
The same objects are reused in all examples:

```{r ro}
df <- new_df()
tbl <- new_tbl()
```

Where needed, we also show examples with hierarchical columns containing a data frame or a matrix:

```{r setup2}
new_tbl2 <- function() {
  tibble(
    tb = tbl,
    m = diag(4)
  )
}

new_df2 <- function() {
  df2 <- new_tbl2()
  class(df2) <- "data.frame"
  class(df2$tb) <- "data.frame"
  df2
}

df2 <- new_df2()
tbl2 <- new_tbl2()
```

```{r show-compare-2, dftbl = TRUE}
new_df()
```

For subset assignment (subassignment, for short), we need a fresh copy of the data for each test.
The `with_*()` functions (omitted here for brevity) allow for a more concise notation.
These functions take an assignment expression, execute it on a fresh copy of the data, and return the data for printing.
The first example prints what's really executed, further examples omit this output.


```{r with-def, include = FALSE}
with_df <- function(code, verbose = FALSE) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    df <- new_df()
    !!code
    df
  })
  if (verbose) rlang::expr_print(rlang::quo_get_expr(full_code))
  rlang::eval_tidy(full_code)
}

with_tbl <- function(code, verbose = FALSE) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    tbl <- new_tbl()
    !!code
    tbl
  })
  if (verbose) rlang::expr_print(rlang::quo_get_expr(full_code))
  rlang::eval_tidy(full_code)
}

with_df2 <- function(code) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    df2 <- new_df2()
    !!code
    df2
  })
  rlang::eval_tidy(full_code)
}

with_tbl2 <- function(code) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    tbl2 <- new_tbl2()
    !!code
    tbl2
  })
  rlang::eval_tidy(full_code)
}
```

```{r with-demo, dftbl = TRUE}
with_df(df$n <- rev(df$n), verbose = TRUE)
```

# Columns

The subsetting and subassignment operators for data frames and tibbles are particularly tricky, because they support both row and column indexes, both of which are optionally missing.
We resolve this by first defining column-wise subsetting, then row-wise subsetting and the composition of both, then missing indexes.

## Definition of `x[[j]]`.

`x[[j]]` is equivalent to `.subset2(x, j)`.

```{r double-bracket-equivalent-to-subset2, dftbl = TRUE}
df[[1]]
.subset2(df, 1)
df[[3]]
.subset2(df, 3)
df2[[1]]
.subset2(df2, 1)
df2[[2]]
.subset2(df2, 2)
```

### Corollary

Accessing `NA` or missing columns returns `NULL`.
Out-of-bounds indexing throws an error.

```{r double-bracket-j-na, dftbl = TRUE}
df[[NA]]
df[[NA_integer_]]
df[[NA_character_]]
df[["x"]]
df[[4]]
```

`[[` requires scalar `vec_as_index(j)`.

```{r double-bracket-requires-scalar-j-index, dftbl = TRUE}
df[[1]]
df[[1:2]]
df[[1:3]]
df[["n"]]
df[[c("n", "c")]]
df[[TRUE]]
df[[FALSE]]
```

`x[[j]]` always returns an object of size `nrow(x)` if the column exists.

```{r double-bracket-retains-size, dftbl = TRUE}
vec_size(df[[1]])
vec_size(df[[3]])
vec_size(df2[[1]])
vec_size(df2[[2]])
```

## Definition of `x[[j]] <- a`.

`x[[j]] <- a` is equivalent to restoring to the original class after assigning the (potentially recycled) value to `unclass(x)`:

```r
xl <- unclass(x)
xl[[j]] <- vec_recycle(a, nrow(x))
vec_restore(xl, x)
```


```{r double-bracket-assign-definition, dftbl = TRUE}
with_df(df[[1]] <- 0)
with_df(df[[3]] <- 4:1)
with_df2(df2[[1]] <- 0)
with_df2(df2[[2]] <- 4:1)
```

### Corollary

`[[<-` requires scalar `vec_as_index(j)` (with the exception of new columns, see below).

```{r double-bracket-assign-requires-scalar-j-index, dftbl = TRUE}
with_df(df[[1]] <- 0)
with_df(df[[1:2]] <- 0)
with_df(df[[1:3]] <- 0)
with_df(df[["n"]] <- 0)
with_df(df[[c("n", "c")]] <- 0)
with_df(df[[TRUE]] <- 0)
with_df(df[[FALSE]] <- 0)
with_df(df[[NA]] <- 0)
with_df(df[[NA_character_]] <- 0)
with_df(df[[NA_integer_]] <- 0)
```

`x[[j]] <- a` requires `vec_size(a) == nrow(x)` or `vec_size(a) == 1`.

```{r double-bracket-requires-size, dftbl = TRUE}
with_df(df[[1]] <- 1)
with_df(df[[1]] <- 4:1)
with_df(df[[1]] <- 3:1)
with_df(df[[1]] <- 2:1)
```

`[[<-` supports appending a new column at the end.

```{r double-bracket-assign-supports-new, dftbl = TRUE}
with_df(df[["x"]] <- 0)
with_df(df[[4]] <- 0)
with_df(df[[5]] <- 0)
```

`[[<-` supports changing the type of an existing column, also across the principal column types:

- atomic: `df[[1]]` and `df[[2]]`
- list: `df[[3]]`
- data frame: `df2[[1]]`
- matrix: `df2[[2]]`


```{r double-bracket-assign-supports-type-change, dftbl = TRUE}
with_df(df[[1]] <- df[[2]])
with_df(df[[2]] <- df[[3]])
with_df(df[[3]] <- df2[[1]])
with_df2(df2[[1]] <- df2[[2]])
with_df2(df2[[2]] <- df[[1]])
```

`[[<-` supports removing a column by assigning `NULL` to it.

```{r double-bracket-assign-supports-null, dftbl = TRUE}
with_df(df[[1]] <- NULL)
with_df2(df2[[2]] <- NULL)
```

## Columns don't have inner names.

```{r columns-dont-have-names, dftbl = TRUE}
with_df(df[["x"]] <- c(a = 4, b = 3, c = 2, d = 1))[["x"]]
with_df(df[["x"]] <- rlang::set_names(letters[4:1]))[["x"]]
```

### Exception

List columns can have inner names:

```{r list-columns-can-have-names, dftbl = TRUE}
with_df(df[["x"]] <- list(a = 4, b = 3, c = 2, d = 1))[["x"]]
```

## Definition of `x$name`.

`x$name` is equivalent to `x[["name"]]`.

```{r dollar-equivalent-to-subset, dftbl = TRUE}
df$n
df[["n"]]
df$li
df[["li"]]
with_df(df$n <- 0)
with_df(df[["n"]] <- 0)
df2$tb
df2[["tb"]]
df2$m
df2[["m"]]
with_df2(df2$df <- df[1, ])
with_df2(df2[["df"]] <- df[1, ])
with_df2(df2$m <- df2$m[1, , drop = FALSE])
with_df2(df2[["m"]] <- df2[["m"]][1, , drop = FALSE])
```

### Corollary

`$` does not implement partial matching.
For compatibility with code that probes columns and compares with `NULL`, only a warning is raised.

```{r dollar-equivalent-to-subset-pmatch, dftbl = TRUE}
df$l
df[["l"]]
with_df(df$l <- 0)
with_df(df[["l"]] <- 0)
```

## Definition of `x[j]`.

Equivalent to restoring `.subset(x, vec_as_index(j))` to the original class.

```{r bracket-j-definition, dftbl = TRUE}
df[1:2]
df[0:2]
df[-2]
df[-1:2]
df["c"]
df[c(TRUE, FALSE, TRUE)]
df[TRUE]
```

### Corollaries

`NA` columns are not supported.

```{r bracket-j-na, dftbl = TRUE}
df[NA]
df[NA_integer_]
df[NA_character_]
```

Out-of-bounds indexing (and recycling of logical vectors of size > 1) is not supported.

```{r bracket-j-oob, dftbl = TRUE}
df[4]
df[-4]
df["x"]
df[c(TRUE, FALSE, TRUE, FALSE)]
df[c(TRUE, FALSE)]
```


`x[j]` retains the number of rows in the input.

```{r bracket-retains-nrow, dftbl = TRUE}
nrow(df[])
nrow(df[1])
nrow(df[3])
nrow(df2[1])
nrow(df2[2])
```


## Definition of `x[j] <- list(...)`.

`x[j] <- a` is equivalent to converting `j` to column indexes or column names and performing `x[[jj]] <- ...` in a loop.

For converting indexes, the following (internal) function is used.

```r
# With logic for defining names of new columns, see below
j <- vec_as_new_col_index(j, x, a)
```

```{r vec-as-new-col-index}
# Existing columns
tibble:::vec_as_new_col_index(2:3, df, list(2, 3))
tibble:::vec_as_new_col_index(-3, df, list(2, 3))
tibble:::vec_as_new_col_index(c(TRUE, FALSE, TRUE), df, list(2, 3))
#
#
# New columns
tibble:::vec_as_new_col_index("x", df, list(y = 0))
tibble:::vec_as_new_col_index(4, df, list(y = 0))
tibble:::vec_as_new_col_index(4, df, list(0))
#
#
# Errors
tibble:::vec_as_new_col_index(NA, df, list(0))
tibble:::vec_as_new_col_index(NA_integer_, df, list(0))
tibble:::vec_as_new_col_index(NA_character_, df, list(0))
tibble:::vec_as_new_col_index(5, df, list(0))
```

For accessing the name or index of a target column, the following helper is used:

```r
index_or_name <- function(j, ja) {
  index <- j[[ja]]
  if (!is.na(index)) index else names(j)[[ja]]
}
```

Below is a simple version of the update loop:

```r
# Create, update or remove, indexed by position
for (ja in seq_along(j)) {
  jx <- index_or_name(j, ja)
  x[[jx]] <- a[[ja]] # with implicit recycling
}
```

Adding, updating and removing columns may occur in arbitrary order.
A robust implementation that avoids index mismatches might look more like this:

```r
a_null <- map_lgl(a, is_null)

# Create or update, indexed by position
for (ja in which(!a_null)) {
  jx <- index_or_name(j, ja)
  x[[jx]] <- a[[ja]] # with implicit recycling
}

# Remove
j_remove <- j[a_null]
if (has_length(j_remove)) x <- x[-j_remove]
```

```{r bracket-assign-def, dftbl = TRUE}
with_df(df[1:2] <- list("x", 4:1))
with_df(df[c("li", "x", "c")] <- list("x", 4:1, NULL))
with_df(df[1:2] <- list(NULL, 4:1))
```

### Corollaries

`NA` indexes are not supported.

```{r bracket-assign-na, dftbl = TRUE}
with_df(df[NA] <- list("x"))
with_df(df[NA_integer_] <- list("x"))
with_df(df[NA_character_] <- list("x"))
```

`[<-` supports changing the type of an existing column, also across the principal column types:

- atomic: `df[[1]]` and `df[[2]]`
- list: `df[[3]]`
- data frame: `df2[[1]]`
- matrix: `df2[[2]]`


```{r bracket-assign-supports-type-change, dftbl = TRUE}
with_df(df[1] <- df[2])
with_df(df[2] <- df[3])
with_df(df[3] <- df2[1])
with_df2(df2[1] <- df2[2])
with_df2(df2[2] <- df[1])
```

Appending columns at the end (without gaps) is supported.
The name of new columns is determined by the LHS, the RHS, or by name repair (in that order of precedence).

```{r bracket-assign-names, dftbl = TRUE}
with_df(df[c("x", "y")] <- tibble("x", x = 4:1))
with_df(df[3:4] <- list("x", x = 4:1))
with_df(df[4] <- list(4:1))
with_df(df[5] <- list(4:1))
```

`x[j]` and `x[[j]]` can be used interchangeably on the LHS or RHS of an assignment:

```{r double-bracket-equivalent-to-unwrap-single-bracket-update, dftbl = TRUE}
with_df(df[[1]] <- df[[3]])
with_df(df[1] <- list(df[[3]]))
with_df(df[[3]] <- df[[1]])
with_df(df[3] <- list(df[[1]]))
with_df2(df2[[1]] <- df[[1]])
with_df2(df2[1] <- list(df[[1]]))
with_df2(df2[[2]] <- df[[3]])
with_df2(df2[2] <- list(df[[3]]))
```

## Definition of `x[j] <- list(a)`.

`x[j] <- a` is equivalent to `x[j] <- rep_along(j, a)` if `is_list(a, 1)`.

```{r bracket-assign-recycles, dftbl = TRUE}
with_df(df[1:2] <- list(0))
with_df(df[1:2] <- list(0, 0))
with_df(df[1:3] <- list(0))
with_df(df[1:3] <- list(0, 0, 0))
```

### Corollary

Only lists of length one on the RHS are recycled.

```{r bracket-assign-recycles-one, dftbl = TRUE}
with_df(df[1:2] <- list(0, 0, 0))
with_df(df[1:3] <- list(0, 0))
```

## Definition of `x[j] <- a`.

`x[j] <- a` is equivalent to `x[j] <- list(a)` if `is_atomic(a)` or `is_null(a)`.

```{r bracket-assign-wraps, dftbl = TRUE}
with_df(df[1] <- 0)
with_df(df[1] <- list(0))
with_df(df[1] <- 4:1)
with_df(df[1] <- list(4:1))
with_df(df[1] <- NULL)
with_df(df[1] <- list(NULL))
```

# Rows

## Definition of `x[i, ]`.

Applies `vec_slice(, i)` to all columns, for both subsetting and subassignment.

```{r bracket-i, dftbl = TRUE}
df[2:3, ]
df[0:2, ]
df[0, ]
df[-2, ]
df[-1:2, ]
df[NA_integer_, ]
df2[NA_integer_, ]
df[c(FALSE, TRUE, TRUE, FALSE), ]
df[TRUE, ]
df[FALSE, ]
df[NA, ]
with_df(df[2:3, ] <- df[1, ])
with_df(df[0:2, ] <- df[1, ])
with_df(df[0, ] <- df[1, ])
with_df(df[-2, ] <- df[1, ])
with_df(df[-1:2, ] <- df[1, ])
with_df(df[NA_integer_, ] <- df[1, ])
with_df2(df2[NA_integer_, ] <- df2[1, ])
with_df(df[c(FALSE, TRUE, TRUE, FALSE), ] <- df[1, ])
with_df(df[TRUE, ] <- df[1, ])
with_df(df[FALSE, ] <- df[1, ])
with_df(df[NA, ] <- df[1, ])
```

### Corollary

For logical vectors, out-of-bounds indexing and recycling of size > 1 are not supported.
(Character and numeric vectors are exceptions that are discussed below.)

```{r bracket-i-oob-lgl, dftbl = TRUE}
df[c(TRUE, FALSE), ]
df[c(TRUE, FALSE, TRUE, FALSE, TRUE), ]
with_df(df[c(TRUE, FALSE), ] <- df[1, ])
with_df(df[c(TRUE, FALSE, TRUE, FALSE, TRUE), ] <- df[1, ])
```


### Subassignment corollary

Only values of size one can be recycled.

```{r bracket-i-recycle, dftbl = TRUE}
with_df(df[2:3, ] <- df[1, ])
with_df(df[2:3, ] <- df[1:2, ])
with_df(df[2:4, ] <- df[1:2, ])
with_df2(df2[2:4, ] <- df2[1, ])
with_df2(df2[2:4, ] <- df2[2:3, ])
```


### Exception

For compatibility reasons only a warning is issued for indexing beyond the number of rows.
Appending rows right at the end of the existing data is supported, without warning.

```{r bracket-i-oob-num, dftbl = TRUE}
df[5, ]
df[5:7, ]
df[6, ]
with_df(df[5, ] <- df[1, ])
with_df(df[5:7, ] <- df[1, ])
with_df(df[6, ] <- df[1, ])
df[-5, ]
df[-(5:7), ]
df[-6, ]
with_df(df[-5, ] <- df[1, ])
with_df(df[-(5:7), ] <- df[1, ])
with_df(df[-6, ] <- df[1, ])
```

For compatibility reasons, character vectors that represent numbers are supported.

```{r bracket-i-character, dftbl = TRUE}
df[as.character(1:3), ]
df[as.character(-(1:3)), ]
df[as.character(3:5), ]
df[as.character(-(3:5)), ]
df[NA_character_, ]
with_df(df[as.character(1:3), ] <- df[1, ])
with_df(df[as.character(-(1:3)), ] <- df[1, ])
with_df(df[as.character(3:5), ] <- df[1, ])
with_df(df[as.character(-(3:5)), ] <- df[1, ])
with_df(df[NA_character_, ] <- df[1, ])
```

## Definition of `x[i, j]`.

`x[i, j]` is equivalent to `x[j][i, ]`.

```{r bracket-i-j-equivalent-to-j-subset-then-i, dftbl = TRUE}
df[1, 1]
df[1][1, ]
df[1, 2:3]
df[2:3][1, ]
df[2:3, 1]
df[1][2:3, ]
df2[2:3, 1:2]
df2[1:2][2:3, ]
```

### Corollaries

`x[i, j] <-` can update only existing columns, it cannot create or remove columns.

```{r bracket-ij-update-existing-only, dftbl = TRUE}
with_df(df[2:3, "n"] <- 1)
with_df(df[2:3, "x"] <- 1)
with_df(df[2:3, "n"] <- NULL)
```

`x[i, j] <-` can't change the data type of existing columns.

```{r bracket-i-data-type, dftbl = TRUE}
with_df(df[2:3, 1] <- df[1:2, 2])
with_df(df[2:3, 2] <- df[1:2, 3])
with_df(df[2:3, 3] <- df2[1:2, 1])
with_df2(df2[2:3, 1] <- df2[1:2, 2])
with_df2(df2[2:3, 2] <- df[1:2, 1])
```

`x[i, j] <-` can't append rows.

```{r append-rows-only-all-columns, dftbl = TRUE}
with_df(df[5, "n"] <- list(0))
```


## Definition of `x[[i, j]]`.

`x[[i, j]]` is equivalent to `x[i, ][[j]]`.

```{r double-bracket-i-j-equivalent-to-row-subset-then-j, dftbl = TRUE}
df[[1, 1]]
df[1, ][[1]]
df[[1, 3]]
df[1, ][[3]]
df2[[1, 1]]
df2[1, ][[1]]
df2[[1, 2]]
df2[1, ][[2]]
with_df(df[[1, 1]] <- 0)
with_df(df[1, ][[1]] <- 0)
with_df(df[[1, 3]] <- list(NULL))
with_df(df[1, ][[3]] <- list(NULL))
with_df2(df2[[1, 1]] <- df[1, ])
with_df2(df2[1, ][[1]] <- df[1, ])
with_df2(df2[[1, 2]] <- t(1:4))
with_df2(df2[1, ][[2]] <- t(1:4))
```

`vec_as_index(i)` must be scalar.

```{r double-bracket-requires-scalar-i-index, dftbl = TRUE}
df[[1:2, 1]]
with_df(df[[1:2, 1]] <- 0)
```


### Corollaries

`x[[i, j]]` always returns an object of size 1.

```{r double-bracket-double-index-size-one, dftbl = TRUE}
vec_size(df[[2, 1]])
vec_size(df[[2, 3]])
vec_size(df2[[2, 1]])
vec_size(df2[[2, 2]])
vec_size(df[[NA, 1]])
vec_size(df[[NA, 3]])
vec_size(df2[[NA, 1]])
vec_size(df2[[NA, 2]])
```

`x[[i, j]]` and `x[i, ][[j]]` can be used interchangeably on the LHS or RHS of an assignment for the four principal column types:

- atomic: `df[[1]]`
- list: `df[[3]]`
- data frame: `df2[[1]]`
- matrix: `df2[[2]]`

```{r double-bracket-i-j-assign, dftbl = TRUE}
with_df(df[[1, 1]] <- df[2, ][[1]])
with_df(df[1, 1] <- list(df[[2, 1]]))
with_df(df[[1, 3]] <- df[2, ][[3]])
with_df(df[1, 3] <- list(df[[2, 3]]))
with_df2(df2[[1, 1]] <- df2[2, ][[1]])
with_df2(df2[1, 1] <- list(df2[[2, 1]]))
with_df2(df2[[1, 2]] <- df2[2, ][[2]])
with_df2(df2[1, 2] <- list(df2[[2, 2]]))
```

`x[[i, j]]` is equivalent to `x[i, j][[1]]` with the additional requirement `vec_as_index(i)` and `vec_as_index(j)` scalar.
 
```{r double-bracket-i-j-equivalent-to-bracket-then-subset2-1, dftbl = TRUE}
df[[1, 2]]
df[1, 2][[1]]
with_df(df[[1, 2]] <- "x")
with_df(df[1, 2] <- list("x"))
```

`x[[i, ]]` is not supported.

```{r double-bracket-j-missing-not-supported, dftbl = TRUE}
df[[1, ]]
with_df(df[[1, ]] <- 0)
```


# Missing `j` indexes

## Definition of `x[]`.

`x[]` is equivalent to `x[seq_len(ncol(x))]`.

```{r bracket-empty, dftbl = TRUE}
df[]
with_df(df[] <- df)
with_df(df[] <- df[1, ])
with_df(df[] <- df[1:2, ])
with_df(df[] <- df2)
df2[]
with_df2(df2[] <- df2)
with_df2(df2[] <- df2[1, ])
with_df2(df2[] <- df2[1:2, ])
with_df2(df2[] <- df)
```


## Definition of `x[, j]`.

`x[, j]` is equivalent to `x[j]`.

```{r bracket-missing-i, dftbl = TRUE}
df[, 2:3]
df[2:3]
df2[, 1:2]
df2[1:2]
with_df(df[, 2:3] <- df[1:2])
with_df(df[2:3] <- df[1:2])
with_df2(df2[, 1:2] <- df2[2:1])
with_df2(df2[1:2] <- df2[2:1])
```

### Corollaries

`[` always returns a tibble.

```{r bracket-drop, dftbl = TRUE}
df[, 1]
df[1]
df[, 1, drop = FALSE]
df[1, drop = FALSE]
```

`x[,]` is equivalent to `x[]`.

```{r bracket-comma, dftbl = TRUE}
df[,]
with_df(df[,] <- df)
with_df(df[,] <- df[1, ])
with_df(df[,] <- df[1:2, ])
with_df(df[,] <- df2)
df2[,]
with_df2(df2[,] <- df2)
with_df2(df2[,] <- df2[1, ])
with_df2(df2[,] <- df2[1:2, ])
with_df2(df2[,] <- df)
```

### Exception

`drop = TRUE` returns a vector when subsetting a single column with `x[, j]`, this is for backward compatibility with code that uses an explicit `drop = TRUE` to access columns as vectors.

```{r bracket-always-returns-tibble-drop, dftbl = TRUE}
df[, 1, drop = TRUE]
df[1, , drop = TRUE]
```


```{r check, dftbl = TRUE}
stopifnot(identical(df, new_df()))
```
