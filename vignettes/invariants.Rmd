---
title: "Invariants for subsetting and subassignment"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{invariants}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">
.dftbl {
    width: 100%;
    table-layout: fixed;
    display: inline-table;
}

.error pre code {
    color: red;
}

.warning pre code {
    color: violet;
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  error = TRUE,
  collapse = TRUE,
  comment = "#>"
)

tibble:::set_dftbl_hooks()

options(
  lifecycle_disable_warnings = FALSE,
  lifecycle_verbose_soft_deprecation = TRUE,
  lifecycle_repeat_warnings = TRUE
)
```

This vignette is an attempt to define invariants in the behavior of `$`, `[[` and `[`, and their assignment counterparts `$<-`, `[[<-` and `[<-`.
For each invariant an example is given.
Currently, the `vignette("subset")` and `vignette("subassign")` articles give a more comprehensive overview, but will be merged into this article at some point.

```{r setup}
library(tibble)

new_df <- function() {
  df <- data.frame(a = 1:4)
  df$b <- letters[5:8]
  df$cd <- list(9, 10:11, 12:14, "text")
  df
}

new_tbl <- function() {
  as_tibble(new_df())
}
```

Results of the same code for data frames and tibbles are presented side by side:

```{r show, dftbl = TRUE, dftbl_always = TRUE}
new_df()
```

In the following, if the results are identical (after converting to a data frame if necessary), only the tibble result is shown, as in the example below.
This allows to spot differences easier.

```{r show-compare, dftbl = TRUE}
new_df()
```

Subsetting operations are read-only.
The same objects are reused in all examples:

```{r ro}
df <- new_df()
tbl <- new_tbl()
```

We're also showing examples with hierarchical columns containting a data frame or a matrix where appropriate:

```{r setup2}
new_tbl2 <- function() {
  tibble(
    e = tbl,
    f = diag(4)
  )
}

new_df2 <- function() {
  df2 <- new_tbl2()
  class(df2) <- "data.frame"
  class(df2$e) <- "data.frame"
  df2
}

df2 <- new_df2()
tbl2 <- new_tbl2()
```

```{r show-compare-2, dftbl = TRUE}
new_df()
```

For subset assignment (short: subassignment), we need a fresh copy of the data for each test.
The `with_*()` functions allow for a more concise notation
(`with_tbl()` and `with_*2()` omitted here for brevity):

```{r with-df-def}
with_df <- function(code, verbose = FALSE) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    df <- new_df()
    !!code
    df
  })
  if (verbose) rlang::expr_print(rlang::quo_get_expr(full_code))
  rlang::eval_tidy(full_code)
}
```


```{r with-tbl-def, include = FALSE}
with_tbl <- function(code, verbose = FALSE) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    tbl <- new_tbl()
    !!code
    tbl
  })
  if (verbose) rlang::expr_print(rlang::quo_get_expr(full_code))
  rlang::eval_tidy(full_code)
}
```

```{r with-df2-def, include = FALSE}
with_df2 <- function(code) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    df2 <- new_df2()
    !!code
    df2
  })
  rlang::eval_tidy(full_code)
}
```


```{r with-tbl2-def, include = FALSE}
with_tbl2 <- function(code) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    tbl2 <- new_tbl2()
    !!code
    tbl2
  })
  rlang::eval_tidy(full_code)
}
```

This function takes an assignment expression and executes it on a fresh copy of the data.
The first example prints what's really executed, further examples omit this output.

```{r with-demo, dftbl = TRUE}
with_df(df$a <- rev(df$a), verbose = TRUE)
```


# Subsetting and subassignment

## Missing indexes.

`x[]` and `x[,]` are equivalent to `x`.

```{r bracket-empty, dftbl = TRUE}
df[]
df[,]
with_df(df[] <- df)
with_df(df[,] <- df)
df2[]
df2[,]
with_df2(df2[] <- df2)
with_df2(df2[,] <- df2)
```

## Definition of `x[i, j]`.

`x[i, j]` is equivalent to `x[j][i, ]` (`i` and/or `j` may be missing).

```{r bracket-i-j-equivalent-to-j-subset-then-i, dftbl = TRUE}
df[1, 1]
df[1][1, ]
df[1, 2:3]
df[2:3][1, ]
df2[1, 1:2]
df2[1:2][1, ]
```

### Corollaries

`x[, j]` is equivalent to `x[j]`; `[` always returns a tibble.

```{r bracket-missing-i, dftbl = TRUE}
df[, 1]
df[1]
df[, 1, drop = FALSE]
df[1, drop = FALSE]
df[, 2:3]
df[2:3]
df2[, 1:2]
df2[1:2]
```

If `i` is given in subassignment, only existing columns can be updated.

```{r bracket-ij-update-existing-only, dftbl = TRUE}
with_df(df["c"] <- 1)
with_df(df[2:3, "c"] <- 1)
```



### Exception

`drop = TRUE` returns a vector when subsetting a single column with two-dimensional indexing, this is for backward compatibility with code that uses an explicit `drop = TRUE` to access columns as vectors.

```{r bracket-always-returns-tibble-drop, dftbl = TRUE}
df[, 1, drop = TRUE]
df[1, , drop = TRUE]
```

## Definition of `x[i, ]`.

Applies `vec_slice(, i)` to all columns.

```{r bracket-i, dftbl = TRUE}
df[2:3, ]
df[0:2, ]
df[-2, ]
df[-1:2, ]
df[NA_integer_, ]
df2[NA_integer_, ]
df[c(FALSE, TRUE, TRUE, FALSE), ]
df[TRUE, ]
df[NA, ]
```

### Corollary

Out-of-bounds indexing (and recycling of logical vectors of size > 1) is not supported.

```{r bracket-i-oob-lgl, dftbl = TRUE}
df[c(TRUE, FALSE), ]
df[c(TRUE, FALSE, TRUE, FALSE, TRUE), ]
with_df(df[c(TRUE, FALSE), ] <- df[1, ])
with_df(df[c(TRUE, FALSE, TRUE, FALSE, TRUE), ] <- df[1, ])
```


### Subassignment corollary

The data type of existing columns can be changed only if `i` is missing.

```{r bracket-i-data-type, dftbl = TRUE}
with_df(df[2:3, 1] <- "x")
with_df(df[2:3, 2] <- 0)
with_df(df[2:3, 3] <- 0)
with_df2(df2[2:3, 1] <- 0)
with_df2(df2[2:3, 2] <- 0)
```


Only values of size one can be recycled.

```{r bracket-i-recycle, dftbl = TRUE}
with_df(df[2:3, ] <- list(0, "x", list(NULL)))
with_df(df[2:3, ] <- list(0:1, c("x", "y"), list(NULL, "")))
with_df(df[2:4, ] <- list(0:1, "x", list(NULL)))
with_df2(df2[2:4, ] <- list(df[1, ]))
with_df2(df2[2:4, ] <- list(df[2:3, ]))
```


### Exception

For compatibility reasons only a warning is issued for indexing beyond the number of rows.
Appending rows right at the end of the existing data is supported, without warning.

```{r bracket-i-oob-num, dftbl = TRUE}
df[5, ]
df[5:7, ]
df[6, ]
with_df(df[5, ] <- list(0, "x", list()))
with_df(df[5:7, ] <- list(0, "x", list()))
with_df(df[6, ] <- list(0, "x", list()))
```


## Definition of `x[[i, j]]`.

`x[[i, j]]` is equivalent to `x[i, ][[j]]`.

```{r double-bracket-i-j-equivalent-to-row-subset-then-j, dftbl = TRUE}
df[[1, 1]]
df[1, ][[1]]
df[[1, 3]]
df[1, ][[3]]
df2[[1, 1]]
df2[1, ][[1]]
df2[[1, 2]]
df2[1, ][[2]]
```


### Corollaries

`x[[i, j]]` and `x[i, ][[j]]` can be used interchangeably on the LHS or RHS of an assignment for the four principal column types:

- atomic: `df[[1]]`
- list: `df[[3]]`
- data frame: `df2[[1]]`
- matrix: `df2[[2]]`

```{r double-bracket-i-j-assign, dftbl = TRUE}
with_df(df[[1, 1]] <- df[2, ][[1]])
with_df(df[1, 1] <- list(df[[2, 1]]))
with_df(df[[1, 3]] <- df[2, ][[3]])
with_df(df[1, 3] <- list(df[2, 3]))
with_df2(df2[[1, 1]] <- df2[2, ][[1]])
with_df2(df2[1, 1] <- list(df2[[2, 1]]))
with_df2(df2[[1, 2]] <- df2[2, ][[2]])
with_df2(df2[1, 2] <- list(df2[[2, 2]]))
```

`x[[i, j]]` is equivalent to `x[i, j][[1]]` with the additional requirement `vec_as_index(j)` scalar.
 
```{r double-bracket-i-j-equivalent-to-bracket-then-subset2-1, dftbl = TRUE}
df[[1, 2]]
df[1, 2][[1]]
with_df(df[[1, 2]] <- "x")
with_df(df[1, 2] <- list("x"))
```
 
## `[[` requires a scalar `i` index?

```{r double-bracket-requires-scalar-i-index, dftbl = TRUE}
df[[1:2, 1]]
with_df(df[[1:2, 1]] <- 0)
```

### Corollary

`x[[i, j]]` always returns an object of size 1.

```{r double-bracket-double-index-size-one, dftbl = TRUE}
vctrs::vec_size(df[[2, 1]])
vctrs::vec_size(df[[2, 3]])
vctrs::vec_size(df2[[2, 1]])
vctrs::vec_size(df2[[2, 2]])
vctrs::vec_size(df[[NA, 1]])
vctrs::vec_size(df[[NA, 3]])
vctrs::vec_size(df2[[NA, 1]])
vctrs::vec_size(df2[[NA, 2]])
```

## Definition of `x$name`.

`x$name` is equivalent to `x[["name"]]`.

```{r dollar-equivalent-to-subset, dftbl = TRUE}
df$a
df[["a"]]
df$cd
df[["cd"]]
df2$e
df2[["e"]]
df2$f
df2[["f"]]
```

### Corollary

`$` does not implement partial matching.
For compatibility with code that probes columns and compares with `NULL`, only a warning is raised.

```{r dollar-equivalent-to-subset-pmatch, dftbl = TRUE}
df$c
df[["c"]]
with_df(df$c <- 0)
with_df(df[["c"]] <- 0)
```


# Subsetting

## Definition of `x[j]`.

Equivalent to restoring `.subset(x, vec_as_index(j))` to the original class.

```{r bracket-j-definition, dftbl = TRUE}
df[1:2]
df[0:2]
df[-2]
df[-1:2]
df["b"]
df[c(TRUE, FALSE, TRUE)]
df[TRUE]
```

### Corollaries

Out-of-bounds indexing (and recycling of logical vectors of size > 1) is not supported.

```{r bracket-j-oob, dftbl = TRUE}
df[4]
df[-4]
df["c"]
df[c(TRUE, FALSE, TRUE, FALSE)]
df[c(TRUE, FALSE)]
```


`x[j]` retains the number of rows in the input.

```{r bracket-retains-nrow, dftbl = TRUE}
nrow(df[])
nrow(df[1])
nrow(df[3])
nrow(df2[1])
nrow(df2[2])
```


### Exception

`NA` columns are not supported.

```{r bracket-j-na, dftbl = TRUE}
df[NA]
df[NA_integer_]
df[NA_character_]
```


## Definition of `x[[j]]`.

`x[[j]]` is equivalent to `.subset2(x, j)`.

```{r double-bracket-equivalent-to-subset2, dftbl = TRUE}
df[[1]]
.subset2(df, 1)
df[[3]]
.subset2(df, 3)
df2[[1]]
.subset2(df2, 1)
df2[[2]]
.subset2(df2, 2)
```

### Corollary

`[[` requires a scalar `j` index.

```{r double-bracket-requires-scalar-j-index, dftbl = TRUE}
df[[1]]
df[[1:2]]
df[[1:3]]
```

`x[[j]]` always returns an object of size `nrow(x)`.

```{r double-bracket-retains-size, dftbl = TRUE}
vctrs::vec_size(df[[1]])
vctrs::vec_size(df[[3]])
vctrs::vec_size(df2[[1]])
vctrs::vec_size(df2[[2]])
```

# Subassignment

## Treatment of atomic or `NULL` on the RHS.

`x[i, j] <- a` is equivalent to `x[i, j] <- list(a)` if `is_atomic(a)` or `is_null(a)`.

```{r bracket-assign-wraps, dftbl = TRUE}
with_df(df[1] <- 0)
with_df(df[1] <- list(0))
with_df(df[1] <- 4:1)
with_df(df[1] <- list(4:1))
with_df(df[1] <- NULL)
with_df(df[1] <- list(NULL))
```

## Treatment of list of length 1 on the RHS.

`x[i, j] <- a` is equivalent to `x[i, j] <- rep_along(j, a)` if `is_list(a, 1)`.

```{r bracket-assign-recycles, dftbl = TRUE}
with_df(df[1:2] <- list(0))
with_df(df[1:2] <- list(0, 0))
with_df(df[1:3] <- list(0))
with_df(df[1:3] <- list(0, 0, 0))
```

### Corollary

Only lists of length one are recycled.

```{r bracket-assign-recycles-one, dftbl = TRUE}
with_df(df[1:2] <- list(0, 0, 0))
with_df(df[1:3] <- list(0, 0))
```

## Definition of `x[j] <- list(...)`.

`x[j] <- a` is equivalent to `x[[jj]] <- ...` in a loop, keeping only columns that are assigned non-NULL values.

```r
# With logic for defining names of new columns, see below
j <- vec_as_index_or_name(j, ncol(x), a)

is_data <- !map_lgl(a, is_null)

# Create or update
for (jj in which(is_data)) x[[ j[[jj]] ]] <- vec_recycle(a[[jj]], nrow(x))

# Remove
j_remove <- j[!is_data]
if (has_length(j_remove)) x <- x[-j_remove]
```

```{r bracket-assign-def, dftbl = TRUE}
with_df(df[1:2] <- list("x", 4:1))
with_df(df[c("cd", "c", "b")] <- list("x", 4:1, NULL))
```

`NA` indexes are not supported.

```{r bracket-assign-na, dftbl = TRUE, eval = FALSE}
with_df(df[NA] <- list("x"))
with_df(df[NA_integer_] <- list("x"))
with_df(df[NA_character_] <- list("x"))
```

The name of new columns is determined by the LHS, the RHS, or by name repair (in that order of preference).

```{r bracket-assign-names, dftbl = TRUE}
with_df(df[c("d", "c")] <- tibble("x", d = 4:1))
with_df(df[3:4] <- list("x", c = 4:1))
with_df(df[4] <- list(4:1))
```


### Corollary

When adding or removing columns, `i` cannot be given (by definition of `x[i, j]`).

```{r change-shape-only-all-rows, dftbl = TRUE}
with_df(df[2:3, "c"] <- list(0))
with_df(df[2:3, "b"] <- NULL)
```

When appending rows, `j` cannot be given (by definition of `x[i, j]`).

```{r append-rows-only-all-columns, dftbl = TRUE}
with_df(df[5, "a"] <- list(0))
```



## Definition of `x[[j]] <- a`.

`x[[j]] <- a` is equivalent to `x[j] <- list(a)`.

```{r double-bracket-assign-equivalent-to-bracket-assign-list, dftbl = TRUE}
with_df(df[[1]] <- 0)
with_df(df[1] <- list(0))
with_df(df[[3]] <- 0)
with_df(df[3] <- list(0))
with_df2(df2[[1]] <- 0)
with_df2(df2[1] <- list(0))
with_df2(df2[[2]] <- 0)
with_df2(df2[2] <- list(0))
```

`[[<-` requires a scalar `j` index.

```{r double-bracket-assign-requires-scalar-j-index, dftbl = TRUE}
with_df(df[[1]] <- 0)
with_df(df[[1:2]] <- 0)
with_df(df[[1:3]] <- 0)
```

### Corollary

`x[[j]] <- a` requires `vec_size(a) == nrow(x)` or `vec_size(a) == 1`.

```{r double-bracket-requires-size, dftbl = TRUE}
with_df(df[[1]] <- 1)
with_df(df[[1]] <- 4:1)
with_df(df[[1]] <- 3:1)
with_df(df[[1]] <- 2:1)
```

`x[j]` and `x[[j]]` can be used interchangeably on the LHS or RHS of an assignment for the four principal column types:

- atomic: `df[[1]]`
- list: `df[[3]]`
- data frame: `df2[[1]]`
- matrix: `df2[[2]]`

```{r double-bracket-equivalent-to-unwrap-single-bracket-update, dftbl = TRUE}
with_df(df[[1]] <- df[[3]])
with_df(df[[1]] <- df2[[1]])
with_df(df[[1]] <- df2[[2]])
with_df(df[1] <- list(df[[3]]))
with_df(df[1] <- list(df2[[1]]))
with_df(df[1] <- list(df2[[2]]))
with_df(df[[3]] <- df[[1]])
with_df(df[[3]] <- df2[[1]])
with_df(df[[3]] <- df2[[2]])
with_df(df[3] <- list(df[[1]]))
with_df(df[3] <- list(df2[[1]]))
with_df(df[3] <- list(df2[[2]]))
with_df2(df2[[1]] <- df[[1]])
with_df2(df2[[1]] <- df[[3]])
with_df2(df2[[1]] <- df2[[2]])
with_df2(df2[1] <- list(df[[1]]))
with_df2(df2[1] <- list(df[[3]]))
with_df2(df2[1] <- list(df2[[2]]))
with_df2(df2[[2]] <- df[[1]])
with_df2(df2[[2]] <- df[[3]])
with_df2(df2[[2]] <- df2[[1]])
with_df2(df2[2] <- list(df[[1]]))
with_df2(df2[2] <- list(df[[3]]))
with_df2(df2[2] <- list(df2[[1]]))
```


## Columns don't have inner names.

```{r columns-dont-have-names, dftbl = TRUE}
with_df(df$x <- c(a = 4, b = 3, c = 2, d = 1))$x
with_df(df$x <- rlang::set_names(letters[4:1]))$x
```

### Exception

List columns can have inner names:

```{r list-columns-can-have-names, dftbl = TRUE}
with_df(df$x <- list(a = 4, b = 3, c = 2, d = 1))$x
```





```{r check, dftbl = TRUE}
stopifnot(identical(df, new_df()))
```
