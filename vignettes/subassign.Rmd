---
title: "Subsetting and subassignment"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{subassign}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  error = TRUE,
  collapse = TRUE,
  comment = "#>"
)

dftbl_opts_hook <- function(options) {
  df_code <- options$code
  tibble_code <- gsub("df", "tbl", df_code)
  new_code <- as.vector(t(matrix(c(df_code, tibble_code), ncol = 2)))
  options$code <- new_code
  options$width <- 36
  options
}

knitr::opts_hooks$set(dftbl = dftbl_opts_hook)

old_width <- NULL

dftbl_knit_hook <- function(before, options, envir) {
  if (before) {
    old_width <<- options(width = 40)
  } else {
    options(old_width)
    old_width <<- NULL
  }
}

knitr::knit_hooks$set(dftbl = dftbl_knit_hook)

old_source_hook <- knitr::knit_hooks$get("source")

dftbl_source_even <- TRUE

dftbl_source_hook_one <- function(x) {
  if (dftbl_source_even) {
    x <- paste0('</td></tr><tr style="vertical-align:top"><td>\n\n', x)
  } else {
    x <- paste0("</td><td>\n\n", x)
  }

  dftbl_source_even <<- !dftbl_source_even
  x
}

dftbl_source_hook <- function(x, options) {
  x <- vapply(x, old_source_hook, options, FUN.VALUE = character(1))
  if (isTRUE(options$dftbl)) {
    x <- vapply(x, dftbl_source_hook_one, FUN.VALUE = character(1))
  }
  paste(x, collapse = "\n")
}

knitr::knit_hooks$set(source = dftbl_source_hook)

old_chunk_hook <- knitr::knit_hooks$get("chunk")

dftbl_chunk_hook <- function(x, options) {
  x <- old_chunk_hook(x, options)
  if (isTRUE(options$dftbl)) {
    x <- paste0('<table style="width: 100%; table-layout: fixed; "><tbody><tr><td>\n\n', x, "\n\n</td></tr></tbody></table>")
    x <- gsub("<tr><td>\n\n</td></tr>", "", x, fixed = TRUE)
  }
  x
}

knitr::knit_hooks$set(chunk = dftbl_chunk_hook)

options(
  lifecycle_disable_warnings = FALSE,
  lifecycle_verbose_soft_deprecation = TRUE,
  lifecycle_repeat_warnings = TRUE
)
```

```{r setup}
library(tibble)
```

This vignette is an attempt to provide a comprehensive overview over all subsetting and subassignment operations, highlighting where the tibble implementation differs from the data frame implementation.

```{r def}
new_df <- function() {
  df <- data.frame(a = 1:4, b = letters[5:8])
  df$cd <- list(9, 10:11, 12:14, "text")
  df
}

new_tbl <- function() {
  as_tibble(new_df())
}
```

```{r show, dftbl = TRUE}
new_df()
```


## Subsetting

Subsetting operations are read-only.

```{r ro, dftbl = TRUE}
df <- new_df()
```

### $

With `$` subsetting, accessing a missing column gives a warning.
Inexact matching is not supported:

```{r dollar, dftbl = TRUE}
df$a
df$"a"
df$a[2:3]
df$cd
df$c
df$d
```

### [

With `[` subsetting, tibbles always return a tibble.
The `drop` argument is supported but has different defaults:

```{r bracket, dftbl = TRUE}
df["a"]
df["a", drop = FALSE]
df["a", drop = TRUE]
df[, "a"]
df[, "a", drop = FALSE]
df[, "a", drop = TRUE]
df[c("a", "b")]
df[, c("a", "b")]

df[1, ]
df[1:2, ]

df[1, "a"]
df[1, "a", drop = FALSE]
df[1, "a", drop = TRUE]
df[1:2, "a"]
df[1:2, "a", drop = FALSE]
df[1:2, "a", drop = TRUE]
df[1, c("a", "b")]
df[1:2, c("a", "b")]
```

### [[

The `exact` argument is not supported by tibbles.
With two indexes, a single element is returned.
Exotic variants like recursive indexing are deprecated for tibbles.

```{r double-bracket, dftbl = TRUE}
df[["a"]]
df[["cd", exact = TRUE]]
df[["cd", exact = FALSE]]
df[["c", exact = TRUE]]
df[["c", exact = FALSE]]

df[[2, "a"]]
df[[2, "cd"]]
df[[1:2, "cd"]]
df[[2, "c"]]
df[[1:2, "c"]]

df[[c(1, 2)]]
```

## Subassignment

For subassignment, we need a fresh copy of the data for each test.
The `with_*()` functions allow for a more concise notation
(`with_tbl()` omitted here for brevity):

```{r with-df-def}
with_df <- function(code, verbose = FALSE) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    df <- new_df()
    !!code
    df
  })
  if (verbose) rlang::expr_print(rlang::quo_get_expr(full_code))
  rlang::eval_tidy(full_code)
}
```


```{r with-tbl-def, include = FALSE}
with_tbl <- function(code, verbose = FALSE) {
  code <- rlang::enexpr(code)
  
  full_code <- rlang::quo({
    tbl <- new_tbl()
    !!code
    tbl
  })
  if (verbose) rlang::expr_print(rlang::quo_get_expr(full_code))
  rlang::eval_tidy(full_code)
}
```

This function takes an assignment expression and executes it on a fresh copy of the data.
The first example prints what's really executed, further examples omit this output.

```{r with-demo, dftbl = TRUE}
with_df(df$a <- rev(df$a), verbose = TRUE)
```


### $

#### Scalars

```{r dollar-assign-scalar, dftbl = TRUE}
with_df(df$a <- 1)
with_df(df$b <- 1)
with_df(df$c <- 1)
with_df(df$cd <- 1)
```

#### Full length

```{r dollar-assign-full, dftbl = TRUE}
with_df(df$a <- 4:1)
with_df(df$b <- 4:1)
with_df(df$c <- 4:1)
with_df(df$cd <- 4:1)
```

#### Recycling

```{r dollar-assign-recycle, dftbl = TRUE}
with_df(df$a <- 1:2)
with_df(df$c <- 1:2)
```


### [

### [[
